// The file implements the Entity interface on the Connection struct.
// This is not autogenerated.
package connection

import (
	"crypto/md5"
	"database/sql/driver"
	"encoding/hex"
	"encoding/json"
	"errors"
	"sync"

	"github.com/gofrs/uuid"
	"github.com/meshery/meshkit/database"
	"gorm.io/gorm"
)

var connectionCreation sync.Mutex //Each entity will perform a check and if the connection already doesn't exist, it will create a connection. This lock will make sure that there are no race conditions.

func (h *Connection) GenerateID() (uuid.UUID, error) {
	byt, err := json.Marshal(h)
	if err != nil {
		return uuid.UUID{}, err
	}

	hash := md5.Sum(byt)
	return uuid.FromString(hex.EncodeToString(hash[:]))
}

func (h *Connection) Create(db *database.Handler) (uuid.UUID, error) {

	hID, err := h.GenerateID()
	if err != nil {
		return uuid.UUID{}, err
	}
	var connection Connection
	connectionCreation.Lock()
	defer connectionCreation.Unlock()
	err = db.First(&connection, "id = ?", hID).Error // check if the connection already exists
	if err != nil && err != gorm.ErrRecordNotFound {
		return uuid.UUID{}, err
	}

	// if not exists then create a new host and return the id
	if err == gorm.ErrRecordNotFound {
		h.ID = hID
		err = db.Create(&h).Error
		if err != nil {
			return uuid.UUID{}, err
		}
		return h.ID, nil
	}

	// else return the id of the existing connection
	return connection.ID, nil
}

// TODO: this probably, could be promoted to meshkit,
//
// JSONMap is required here, because if field is map[string]any
// gorm does not know how to work with it and returns
// [error] unsupported data type: &map[]
type JSONMap map[string]any

// Value converts the JSON map to a database value.
func (j JSONMap) Value() (driver.Value, error) {
	return json.Marshal(j)
}

// Scan converts the database value to a JSON map.
func (j *JSONMap) Scan(value any) error {
	bytes, ok := value.([]byte)
	if !ok {
		return errors.New("type assertion to []byte failed")
	}
	return json.Unmarshal(bytes, j)
}
